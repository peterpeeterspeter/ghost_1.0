// üé® Flatlay Renderer - Specialized rendering for flatlay images
// Uses the same AI infrastructure as Ghost Mannequin but with flatlay-specific prompts

import { FlatlayOptions } from '../../types/flatlay';
import { GeminiClient, FilesManager } from '@ghost-platform/shared';

export class FlatlayRenderer {
  private gemini: GeminiClient;
  private filesManager: FilesManager;
  
  constructor() {
    this.gemini = new GeminiClient();
    this.filesManager = new FilesManager();
  }
  
  /**
   * Render flatlay image using Gemini Flash Image
   */
  async renderFlatlay(
    flatlayImage: string,
    prompt: string,
    originalImage?: string,
    options?: FlatlayOptions
  ): Promise<{ imageUrl: string; processingTime: number }> {
    const startTime = Date.now();
    
    try {
      console.log('üé® Starting flatlay rendering...');
      console.log(`üìù Prompt length: ${prompt.length} characters`);
      
      // Configure Gemini model for flatlay generation
      const model = this.gemini.getGenerativeModel({
        model: "gemini-2.5-flash-image-preview",
        generationConfig: {
          temperature: 0.1, // Low temperature for consistent results
        },
        safetySettings: [
          {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_HATE_SPEECH", 
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: "BLOCK_NONE"
          },
          {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: "BLOCK_NONE"
          }
        ]
      });
      
      // Prepare content parts
      const contentParts: any[] = [
        {
          text: prompt
        }
      ];
      
      // Add flatlay image (primary input)
      if (flatlayImage.startsWith('data:image/')) {
        const base64Data = flatlayImage.split(',')[1];
        contentParts.push({
          inlineData: {
            data: base64Data,
            mimeType: 'image/jpeg'
          }
        });
      } else if (flatlayImage.startsWith('https://generativelanguage.googleapis.com/v1beta/files/')) {
        // Use Files API URI
        contentParts.push({
          fileData: {
            fileUri: flatlayImage,
            mimeType: 'image/jpeg'
          }
        });
      } else {
        // Fetch and convert URL to base64
        const response = await fetch(flatlayImage);
        const arrayBuffer = await response.arrayBuffer();
        const base64Data = Buffer.from(arrayBuffer).toString('base64');
        contentParts.push({
          inlineData: {
            data: base64Data,
            mimeType: 'image/jpeg'
          }
        });
      }
      
      // Add original image if provided (for reference)
      if (originalImage) {
        if (originalImage.startsWith('data:image/')) {
          const base64Data = originalImage.split(',')[1];
          contentParts.push({
            inlineData: {
              data: base64Data,
              mimeType: 'image/jpeg'
            }
          });
        } else if (originalImage.startsWith('https://generativelanguage.googleapis.com/v1beta/files/')) {
          contentParts.push({
            fileData: {
              fileUri: originalImage,
              mimeType: 'image/jpeg'
            }
          });
        } else {
          const response = await fetch(originalImage);
          const arrayBuffer = await response.arrayBuffer();
          const base64Data = Buffer.from(arrayBuffer).toString('base64');
          contentParts.push({
            inlineData: {
              data: base64Data,
              mimeType: 'image/jpeg'
            }
          });
        }
      }
      
      console.log(`üì§ Sending ${contentParts.length} content parts to Gemini...`);
      
      // Generate flatlay image
      const result = await model.generateContent(contentParts);
      const response = await result.response;
      
      console.log('‚úÖ Gemini Flash Image generation completed');
      
      // Extract generated image
      const candidates = response.candidates;
      if (!candidates || candidates.length === 0) {
        throw new Error('No candidates returned from Gemini');
      }
      
      const candidate = candidates[0];
      if (!candidate.content || !candidate.content.parts) {
        throw new Error('No content parts in response');
      }
      
      // Find image part
      const imagePart = candidate.content.parts.find(part => 
        part.inlineData && part.inlineData.mimeType && part.inlineData.mimeType.startsWith('image/')
      );
      
      if (!imagePart || !imagePart.inlineData) {
        throw new Error('No image generated by Gemini');
      }
      
      // Convert to data URL
      const imageDataUrl = `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`;
      
      // Upload to storage for permanent URL
      const permanentUrl = await this.uploadToStorage(imageDataUrl);
      
      const processingTime = Date.now() - startTime;
      console.log(`üé® Flatlay rendering completed in ${processingTime}ms`);
      console.log(`üì∏ Generated image: ${permanentUrl}`);
      
      return {
        imageUrl: permanentUrl,
        processingTime
      };
      
    } catch (error) {
      const processingTime = Date.now() - startTime;
      console.error('‚ùå Flatlay rendering failed:', error);
      throw error;
    }
  }
  
  /**
   * Upload generated image to storage
   */
  private async uploadToStorage(imageDataUrl: string): Promise<string> {
    try {
      // For now, return the data URL directly
      // In production, you might want to upload to a CDN or cloud storage
      console.log('üì§ Uploading generated image to storage...');
      
      // Simulate upload delay
      await new Promise(resolve => setTimeout(resolve, 100));
      
      console.log('‚úÖ Image uploaded to storage');
      return imageDataUrl;
      
    } catch (error) {
      console.error('‚ùå Failed to upload image to storage:', error);
      throw error;
    }
  }
  
  /**
   * Generate flatlay-specific prompt based on style and options
   */
  generatePrompt(style: string, options?: FlatlayOptions): string {
    const basePrompt = "Create a professional flatlay product photograph";
    
    const stylePrompts = {
      minimal: "with clean, minimal aesthetic and simple composition",
      lifestyle: "with natural, relaxed styling and lifestyle appeal", 
      commercial: "with commercial e-commerce styling and professional presentation",
      editorial: "with artistic, editorial-style composition and visual interest"
    };
    
    const backgroundPrompts = {
      white: "on a pure white background",
      colored: "on a subtle colored background that complements the garment",
      textured: "on a subtle textured background",
      transparent: "with a transparent background"
    };
    
    const lightingPrompts = {
      natural: "using natural, soft lighting",
      studio: "using professional studio lighting with even illumination",
      soft: "using soft, diffused lighting",
      dramatic: "using dramatic lighting with interesting shadows"
    };
    
    const compositionPrompts = {
      centered: "with the garment centered in the frame",
      asymmetric: "using asymmetric composition for visual interest",
      grid: "arranged in a grid-like composition",
      organic: "using organic, flowing composition"
    };
    
    let prompt = basePrompt;
    
    if (stylePrompts[style as keyof typeof stylePrompts]) {
      prompt += ` ${stylePrompts[style as keyof typeof stylePrompts]}`;
    }
    
    if (options?.background && backgroundPrompts[options.background as keyof typeof backgroundPrompts]) {
      prompt += ` ${backgroundPrompts[options.background as keyof typeof backgroundPrompts]}`;
    }
    
    if (options?.lighting && lightingPrompts[options.lighting as keyof typeof lightingPrompts]) {
      prompt += ` ${lightingPrompts[options.lighting as keyof typeof lightingPrompts]}`;
    }
    
    if (options?.composition && compositionPrompts[options.composition as keyof typeof compositionPrompts]) {
      prompt += ` ${compositionPrompts[options.composition as keyof typeof compositionPrompts]}`;
    }
    
    prompt += ". Create a high-quality, professional flatlay photograph suitable for e-commerce use.";
    
    return prompt;
  }
}

